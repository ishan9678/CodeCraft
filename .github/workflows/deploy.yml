name: Deploy to Production

on:
  push:
    branches: [release]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment archive
        run: |
          # Create archive excluding unnecessary files
          tar -czf deployment.tar.gz \
            --exclude=".git" \
            --exclude=".github" \
            --exclude="deployment.tar.gz" \
            --exclude="node_modules" \
            .

      - name: Transfer to production
        uses: appleboy/scp-action@v0.1.6
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "deployment.tar.gz"
          target: "/tmp"
          rm: true  # Remove local file after transfer

      - name: Deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_IP }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -euo pipefail
            echo "=== Starting Deployment ==="

            # Define deployment directory
            DEPLOY_DIR="/CodeCraft"
            TMP_ARCHIVE="/tmp/deployment.tar.gz"

            # Create deployment directory
            echo "üîπ Creating deployment directory..."
            sudo mkdir -p $DEPLOY_DIR
            sudo chown -R ${{ secrets.SERVER_USER }}: $DEPLOY_DIR

            # Clean previous deployment
            echo "üîπ Cleaning previous deployment..."
            rm -rf $DEPLOY_DIR/*

            # Extract new deployment
            echo "üîπ Extracting new deployment..."
            tar -xzf $TMP_ARCHIVE -C $DEPLOY_DIR
            rm -f $TMP_ARCHIVE

            # Create .env file
            echo "üîπ Creating .env file..."
            cat <<EOF > $DEPLOY_DIR/.env
            DATABASE_URL=${{ secrets.DATABASE_URL }}
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB }}
            GROQ_API_KEY=${{ secrets.GROQ_API_KEY }}
            COMPILER_API_ENDPOINT=${{ secrets.COMPILER_API_ENDPOINT }}
            CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}
            EOF

            # Verify Docker availability
            echo "üîπ Checking Docker..."
            if ! command -v docker &> /dev/null; then
              echo "‚ùå Docker not found!"
              exit 1
            fi

            # Start containers
            echo "üîπ Starting Docker containers..."
            cd $DEPLOY_DIR
            docker-compose down || true
            docker-compose up -d --build --force-recreate

            # Verify deployment
            echo "üîπ Verifying deployment..."
            sleep 10  # Give containers time to start
            RUNNING=$(docker-compose ps --services --filter "status=running" | wc -l)
            TOTAL=$(docker-compose ps --services | wc -l)

            if [ "$RUNNING" -eq "$TOTAL" ]; then
              echo "‚úÖ Deployment successful! ($RUNNING/$TOTAL containers running)"
            else
              echo "‚ùå Deployment failed! ($RUNNING/$TOTAL containers running)"
              docker-compose logs
              exit 1
            fi

            echo "=== Deployment Complete ==="